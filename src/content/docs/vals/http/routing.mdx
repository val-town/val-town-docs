---
title: Routing
generated: 1701279907950
sidebar:
  order: 3
---

import Val from "@components/Val.astro";

One of the coolest things about the Request/Response API is that it works with modern web frameworks, so you can use routing and their helper methods! When an
HTTP val is deployed, it is available at a subdomain like
`handle-valname.web.val.run`, and requests to any subdirectory
or path will be routed to the val.

### Hono

Here's an example with [Hono](https://hono.dev/):

<Val url="https://www.val.town/embed/maxm/honoExample" height="240px" />

### Peko

And one with [Peko](https://peko.deno.dev/):

<Val url="https://www.val.town/embed/maxm/pekoExample" height="300px" />

### nhttp

And [nhttp](https://github.com/nhttp/nhttp):

<Val url="https://www.val.town/embed/maxm/nhttpExample" height="350px" />

### itty-router

A super tiny example with [itty-router](https://itty.dev/itty-router):

<Val url="https://www.val.town/embed/maxm/ittyExample" height="250px" />

### feTS

A simple example of using [feTS server](https://the-guild.dev/openapi/fets/server/quick-start):

<Val url="https://www.val.town/embed/maxm/fetsServerExample" />

Notice, that it exports the `router`, which allows to use the [feTS client](https://the-guild.dev/openapi/fets/client/quick-start) to make routes type safe:

```tsx val
import { type router } from "https://esm.town/v/user/fetsServer";
import { createClient } from "npm:fets";

const client = createClient<typeof router>({
  endpoint: "https://user-fetsServer.web.val.run",
});

// The `response` and `greetings` have proper types automatically inferred
const response = await client["/greetings"].get();
const greetings = await response.json();
console.log(greetings);
``` 